<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Page 1 | Shizi&#39;s BLOG</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  
  
  <meta name="description" content="ALL IS WELL">
<meta property="og:type" content="website">
<meta property="og:title" content="Shizi&#39;s BLOG">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Shizi&#39;s BLOG">
<meta property="og:description" content="ALL IS WELL">
<meta property="og:locale" content="zh_HK">
<meta property="article:author" content="ShiZi">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Shizi&#39;s BLOG" type="application/atom+xml">
  
  <link rel="icon" href="/css/images/favicon.ico">
  
  <link href="https://fonts.googleapis.com/css?family=Open+Sans|Montserrat:700" rel="stylesheet" type="text/css">
  <link href="https://fonts.googleapis.com/css?family=Roboto:400,300,300italic,400italic" rel="stylesheet" type="text/css">
  <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
  <style type="text/css">
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/9749f0/00000000000000000001008f/27/l?subset_id=2&fvd=n5) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/90cf9f/000000000000000000010091/27/l?subset_id=2&fvd=n7) format("woff2");font-weight:500;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/8a5494/000000000000000000013365/27/l?subset_id=2&fvd=n4) format("woff2");font-weight:lighter;font-style:normal;}
    @font-face{font-family:futura-pt;src:url(https://use.typekit.net/af/d337d8/000000000000000000010095/27/l?subset_id=2&fvd=i4) format("woff2");font-weight:400;font-style:italic;}</style>
    
  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Yanone+Kaffeesatz%3A200%2C300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">

  <link rel="stylesheet" id="athemes-headings-fonts-css" href="//fonts.googleapis.com/css?family=Oswald%3A300%2C400%2C700&amp;ver=4.6.1" type="text/css" media="all">
  
<link rel="stylesheet" href="/css/style.css">


  
<script src="/js/jquery-3.1.1.min.js"></script>


  <!-- Bootstrap core CSS -->
  <link rel="stylesheet" href="/css/bootstrap.css" >
  <link rel="stylesheet" href="/css/fashion.css" >
  <link rel="stylesheet" href="/css/glyphs.css" >

<meta name="generator" content="Hexo 7.3.0"></head>



  <body>


  


<header id="allheader" class="site-header" role="banner" 
   >
  <div class="clearfix container">
      <div class="site-branding">

          <h1 class="site-title">
            
              <a href="/" title="Shizi&#39;s BLOG" rel="home"> Shizi&#39;s BLOG </a>
            
          </h1>
          
          
            <div class="site-description">ALL IS WELL</div>
          
            
          <nav id="main-navigation" class="main-navigation" role="navigation">
            <a class="nav-open">Menu</a>
            <a class="nav-close">Close</a>

            <div class="clearfix sf-menu">
              <ul id="main-nav" class="menu sf-js-enabled sf-arrows"  style="touch-action: pan-y;">
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663" linktext="/"> <a class="" href="/">Home</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663" linktext="archives"> <a class="" href="/archives">Archives</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663" linktext="categories"> <a class="" href="/categories">Categories</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663" linktext="tags"> <a class="" href="/tags">Tags</a> </li>
                    
                      <li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-home menu-item-1663" linktext="about"> <a class="" href="/about">About</a> </li>
                    
              </ul>
            </div>
          </nav>

      </div>
  </div>
</header>


  <div id="container">
    <div id="wrap">
            
      <div id="content" class="outer">
        
          <section id="main">
  
    <article id="post-Rust基础3-数据类型（三）结构体"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/Rust-study-notes/Rust%E5%9F%BA%E7%A1%803-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93/">Rust基础3-数据类型（三）结构体</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/Rust-study-notes/Rust%E5%9F%BA%E7%A1%803-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93/" class="article-date">
	  <time datetime="2024-10-02T02:36:54.000Z" itemprop="datePublished">十月 2, 2024</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/Rust-study-notes/">Rust study notes</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Rust-基础（3）-数据类型（三）结构体"><a href="#Rust-基础（3）-数据类型（三）结构体" class="headerlink" title="Rust 基础（3） - 数据类型（三）结构体"></a>Rust 基础（3） - 数据类型（三）结构体</h1><h2 id="3-9-结构体（struct）"><a href="#3-9-结构体（struct）" class="headerlink" title="3.9 结构体（struct）"></a>3.9 结构体（struct）</h2><h3 id="3-9-1-定义结构体"><a href="#3-9-1-定义结构体" class="headerlink" title="3.9.1 定义结构体"></a>3.9.1 定义结构体</h3><ul>
<li>使用struct关键字并为整个结构体提供一个名字</li>
<li>结构体的定义位置没有要求，实例化的作用域在定义的范围内即可</li>
<li>大括号中，定义每一部分数据的名字和类型，称为字段（field）</li>
<li>使用逗号分隔每个字段<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    active:<span class="type">bool</span>,</span><br><span class="line">    username:<span class="type">String</span>,</span><br><span class="line">    email:<span class="type">String</span>,</span><br><span class="line">    sign_in_count:<span class="type">u64</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-9-2-实例化结构体"><a href="#3-9-2-实例化结构体" class="headerlink" title="3.9.2 实例化结构体"></a>3.9.2 实例化结构体</h3><ul>
<li>初始化实例时，每个字段都需要进行初始化</li>
<li>初始化时的字段顺序不需要和结构体定义时的顺序一致</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">user1</span> = User&#123;</span><br><span class="line">    email:<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someone@XXX.com&quot;</span>),</span><br><span class="line">    username:<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someone&quot;</span>),</span><br><span class="line">    active:ture,</span><br><span class="line">    sign_in_count:<span class="number">1</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>结构体更新语法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">user2</span> = User&#123;</span><br><span class="line">    ..user1</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>结构体实例字段读写</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读字段</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">user1</span> = User&#123;</span><br><span class="line">    email:<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someone@XXX.com&quot;</span>),</span><br><span class="line">    username:<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someone&quot;</span>),</span><br><span class="line">    active:ture,</span><br><span class="line">    sign_in_count:<span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,user1.email);</span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改（结构体必须是可变类型mut）</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">user1</span> = User&#123;</span><br><span class="line">    email:<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someone@XXX.com&quot;</span>),</span><br><span class="line">    username:<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;someone&quot;</span>),</span><br><span class="line">    active:ture,</span><br><span class="line">    sign_in_count:<span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line">user1.email=<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,user1.email);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-9-3-特殊结构体"><a href="#3-9-3-特殊结构体" class="headerlink" title="3.9.3 特殊结构体"></a>3.9.3 特殊结构体</h3><ul>
<li>元祖结构体（Tuple Struct）</li>
<li>单元结构体（Unit Struct）</li>
</ul>
<h4 id="3-9-3-1-元祖结构体"><a href="#3-9-3-1-元祖结构体" class="headerlink" title="3.9.3.1 元祖结构体"></a>3.9.3.1 元祖结构体</h4><blockquote>
<p>结构体必须有名称，但是结构体字段可以没有名称，这种结构体长得像元祖，因此被称为元祖结构体</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Color</span>(<span class="type">i32</span>,<span class="type">i32</span>,<span class="type">i32</span>);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span>(<span class="type">i32</span>,<span class="type">i32</span>,<span class="type">i32</span>);</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">black</span> = <span class="title function_ invoke__">Color</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">origin</span> = <span class="title function_ invoke__">Point</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;,&#123;&#125;&quot;</span>,black.<span class="number">0</span>,origin.<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-9-3-2-单元结构体"><a href="#3-9-3-2-单元结构体" class="headerlink" title="3.9.3.2 单元结构体"></a>3.9.3.2 单元结构体</h4><blockquote>
<p>如果你定义一个类型，但是不关心类型的内容，只关心他的行为，就可以使用单元结构体</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">AlwaysEqual</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">subject</span>=AlwaysEqual;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">xx</span> <span class="keyword">for</span> <span class="title class_">AlwaysEqual</span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-9-4-结构体的所有权"><a href="#3-9-4-结构体的所有权" class="headerlink" title="3.9.4 结构体的所有权"></a>3.9.4 结构体的所有权</h3><ul>
<li>1.所有权范围，每个字段都有所有权</li>
<li>2.基本类型实现了copy特性，对基本类型的赋值时会发生复制，不会发生所有权转移</li>
<li>3.对于字符串，没有实现copy特性，会发生所有权转移</li>
<li>4.一旦结构体中一个字段发生了所有权转移，那么整个结构体，就不能再被赋值了</li>
<li>5.如果定义结构体使用引用数据类型，需要定义生命周期</li>
</ul>
<blockquote>
<p>tips:关于结构体部分字段发生所有权转移是<strong>部分移动</strong>：<br>在单个变量的解构内，可以同时使用 by-move 和 by-reference 模式绑定。这样做将导致变量的部分移动（partial move），这意味着变量的某些部分将被移动，而其他部分将保留。在这种情况下，后面不能整体使用父级变量，但是仍然可以使用只引用（而不移动）的部分。</p>
</blockquote>
<h3 id="3-9-5-方法"><a href="#3-9-5-方法" class="headerlink" title="3.9.5 方法"></a>3.9.5 方法</h3><h4 id="3-9-5-1-定义方法"><a href="#3-9-5-1-定义方法" class="headerlink" title="3.9.5.1 定义方法"></a>3.9.5.1 定义方法</h4><ul>
<li>使用fn关键字和名称声明，可以拥有参数和返回值，同时包含在某处调用该方法时会执行的代码</li>
<li>方法与函数是不同的，因为它们在结构体的上下文中被定义，并且它们第一个参数总是self，它代表调用该方法的结构体实例</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span>&#123;</span><br><span class="line">    width:<span class="type">u32</span>,</span><br><span class="line">    height:<span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span>&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span>&#123;</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect1</span> = Rectangle&#123;</span><br><span class="line">        width:<span class="number">30</span>,</span><br><span class="line">        height:<span class="number">50</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(rect1.area);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-9-5-2-self、-self和-mut-self"><a href="#3-9-5-2-self、-self和-mut-self" class="headerlink" title="3.9.5.2 self、&amp;self和&amp;mut self"></a>3.9.5.2 self、&amp;self和&amp;mut self</h4><ul>
<li>self表示结构体的所有权转移到方法中，这种形式用的较少</li>
<li>&amp;self表示该方法对结构体不可变借用</li>
<li>&amp;mut self表示该方法对结构体可变借用</li>
</ul>
<h3 id="3-9-6-关联函数"><a href="#3-9-6-关联函数" class="headerlink" title="3.9.6 关联函数"></a>3.9.6 关联函数</h3><ul>
<li>不包含self的方法称为关联函数，用 结构体名::关联函数名() 的方式调用,例如构造函数<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span>&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">new</span>(width:<span class="type">u32</span>, height:<span class="type">u32</span>) <span class="punctuation">-&gt;</span> Rectangle&#123;</span><br><span class="line">        Rectangle&#123;width:width,height:height&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="3-9-7-特质-trait"><a href="#3-9-7-特质-trait" class="headerlink" title="3.9.7 特质 trait"></a>3.9.7 特质 trait</h3><blockquote>
<p>trait 是对未知类型 Self 定义的方法集。该类型也可以访问同一个 trait 中定义的其他方法。类似java定义接口</p>
</blockquote>
<ul>
<li>如果不同类型具有相同的行为，那么我们可以定义一个特质，然后为这些类型实现该特质</li>
<li>定义特征是把一些方法组合在一起，目的是定义一个实现某些目标所必须的行为集合</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">trait</span> <span class="title class_">Shape</span>&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">f64</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span>&#123;</span><br><span class="line">    width:<span class="type">u32</span>,</span><br><span class="line">    height:<span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Shape</span> <span class="keyword">for</span> <span class="title class_">Rectangle</span>&#123; <span class="comment">//在Rectangle结构体实现Shape特质</span></span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">f64</span>&#123;</span><br><span class="line">        (<span class="keyword">self</span>.width * <span class="keyword">self</span>.height) <span class="keyword">as</span> <span class="type">f64</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">print_area</span>(shape: &amp;<span class="keyword">impl</span> <span class="title class_">Shape</span>)&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,shape.<span class="title function_ invoke__">area</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-9-8-打印结构体信息"><a href="#3-9-8-打印结构体信息" class="headerlink" title="3.9.8 打印结构体信息"></a>3.9.8 打印结构体信息</h3><h4 id="3-9-8-1-使用-derive-debug-实现debug的特质"><a href="#3-9-8-1-使用-derive-debug-实现debug的特质" class="headerlink" title="3.9.8.1 使用  #[derive(debug)] 实现debug的特质"></a>3.9.8.1 使用  #[derive(debug)] 实现debug的特质</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(debug)]</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Rectangle</span>&#123;</span><br><span class="line">    width:<span class="type">u32</span>,</span><br><span class="line">    height:<span class="type">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">impl</span> <span class="title class_">Rectangle</span>&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">area</span>(&amp;<span class="keyword">self</span>) <span class="punctuation">-&gt;</span> <span class="type">u32</span>&#123;</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect1</span> = Rectangle&#123;</span><br><span class="line">        width:<span class="number">30</span>,</span><br><span class="line">        height:<span class="number">50</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>,rect1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-9-8-2-使用dbg-打印结构体"><a href="#3-9-8-2-使用dbg-打印结构体" class="headerlink" title="3.9.8.2 使用dbg!()打印结构体"></a>3.9.8.2 使用dbg!()打印结构体</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">rect1</span> = Rectangle&#123;</span><br><span class="line">        width:<span class="number">30</span>,</span><br><span class="line">        height:<span class="number">50</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    dbg!(rect1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-9-8-3-实现Display特质"><a href="#3-9-8-3-实现Display特质" class="headerlink" title="3.9.8.3 实现Display特质"></a>3.9.8.3 实现Display特质</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Display</span> <span class="keyword">for</span> <span class="title class_">Rectangle</span>&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> Formatter&lt;<span class="symbol">&#x27;_</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&#123;</span><br><span class="line">        <span class="comment">// 控制台输出</span></span><br><span class="line">        <span class="built_in">write!</span>()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-9-8-4-实现Debug特质"><a href="#3-9-8-4-实现Debug特质" class="headerlink" title="3.9.8.4 实现Debug特质"></a>3.9.8.4 实现Debug特质</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> <span class="title class_">Debug</span> <span class="keyword">for</span> <span class="title class_">Rectangle</span>&#123;</span><br><span class="line">    <span class="keyword">fn</span> <span class="title function_">fmt</span>(&amp;<span class="keyword">self</span>, f: &amp;<span class="keyword">mut</span> Formatter&lt;<span class="symbol">&#x27;_</span>&gt;) <span class="punctuation">-&gt;</span> <span class="type">Result</span>&#123;</span><br><span class="line">        <span class="comment">// 控制台输出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/Rust-study-notes/">Rust study notes</a>

      
      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-Rust基础3-数据类型（二）字符串"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/Rust-study-notes/Rust%E5%9F%BA%E7%A1%803-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%88%E4%BA%8C%EF%BC%89%E5%AD%97%E7%AC%A6%E4%B8%B2/">Rust基础3-数据类型（二）字符串</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/Rust-study-notes/Rust%E5%9F%BA%E7%A1%803-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%88%E4%BA%8C%EF%BC%89%E5%AD%97%E7%AC%A6%E4%B8%B2/" class="article-date">
	  <time datetime="2024-09-28T08:07:55.000Z" itemprop="datePublished">九月 28, 2024</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/Rust-study-notes/">Rust study notes</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Rust-基础（3）-数据类型（二）字符串"><a href="#Rust-基础（3）-数据类型（二）字符串" class="headerlink" title="Rust 基础（3） - 数据类型（二）字符串"></a>Rust 基础（3） - 数据类型（二）字符串</h1><h2 id="3-8-字符串"><a href="#3-8-字符串" class="headerlink" title="3.8 字符串"></a>3.8 字符串</h2><h3 id="3-8-1-什么是字符串？"><a href="#3-8-1-什么是字符串？" class="headerlink" title="3.8.1 什么是字符串？"></a>3.8.1 什么是字符串？</h3><ul>
<li>字符串是由连续字符组成的连续集合</li>
<li>Rust语言中的字符是Unicode类型，因此每个字符占用4个字节内存空间，但是在字符串中不一样,字符串是Utf-8编码，也就是字符串中的字符所占的字节数是变化的（1-4）</li>
</ul>
<p>对于”hello 中国”这样一个字符串来说，utf-8编码为：英文字符占一个字节，空格占用一个字节，中文一个字占用3个字节</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  h   e   l   l   o   _  中          国</span><br><span class="line">（<span class="number">104</span> <span class="number">101</span> <span class="number">108</span> <span class="number">108</span> <span class="number">111</span> <span class="number">32</span> <span class="number">228</span>,<span class="number">184</span>,<span class="number">173</span> <span class="number">229</span>,<span class="number">155</span>,<span class="number">189</span>）</span><br></pre></td></tr></table></figure>

<h3 id="3-8-2-字符串字面值"><a href="#3-8-2-字符串字面值" class="headerlink" title="3.8.2 字符串字面值"></a>3.8.2 字符串字面值</h3><blockquote>
<p>字符串的字面值来说，我们在编译时就知道其内容，最终字面值文本被直接硬编码进可执行文件，字符串字面量”hello world”就是<strong>str</strong>类型，它被硬编码进可执行程序的数据部分<br>既然我们已经存储了这个字符串，就需要用一种方式来访问它，这就是切片引用 <strong>&amp;str</strong> 的意义所在</p>
</blockquote>
<ul>
<li>&amp;str 是一种不可变引用，所以它没有所有权</li>
<li>str类型是硬编码进可执行文件，也无法被修改</li>
</ul>
<h3 id="3-8-3-String类型"><a href="#3-8-3-String类型" class="headerlink" title="3.8.3 String类型"></a>3.8.3 String类型</h3><ul>
<li>String在rust中是一个复合数据类型，定义如下：<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">struct</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    vec:<span class="type">Vec</span>&lt;<span class="type">u8</span>&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>String可改变，且拥有所有权</li>
</ul>
<blockquote>
<p><strong>&amp;str</strong> 和 <strong>String</strong> 的区别：<br><strong>&amp;str</strong>:这是一个字符串切片，它是固定大小的，并且不能改变<br><strong>String</strong>:这是一个可增长的、可改变的、拥有所有权的、UTF-8编码的字符串类型。它通常用于需要改变或者增长的字符串的情况。</p>
</blockquote>
<h3 id="3-8-4-类型转换"><a href="#3-8-4-类型转换" class="headerlink" title="3.8.4 类型转换"></a>3.8.4 类型转换</h3><h4 id="3-8-4-1-字节数组-u8-Vec-转换-str"><a href="#3-8-4-1-字节数组-u8-Vec-转换-str" class="headerlink" title="3.8.4.1 字节数组[u8]&#x2F;Vec 转换&amp;str"></a>3.8.4.1 字节数组[u8]&#x2F;Vec<u8> 转换&amp;str</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::<span class="type">str</span>;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="comment">// u8数组转&amp;str</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> =[<span class="number">104</span>,<span class="number">101</span>,<span class="number">108</span>,<span class="number">108</span>,<span class="number">111</span>,<span class="number">32</span>,<span class="number">228</span>,<span class="number">184</span>,<span class="number">173</span>,<span class="number">229</span>,<span class="number">155</span>,<span class="number">189</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> =<span class="type">str</span>::<span class="title function_ invoke__">from_utf8</span>(&amp;b).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,s);</span><br><span class="line">    <span class="comment">// 向量转&amp;str</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">c</span> = <span class="built_in">vec!</span>(<span class="number">104</span>,<span class="number">101</span>,<span class="number">108</span>,<span class="number">108</span>,<span class="number">111</span>,<span class="number">32</span>,<span class="number">228</span>,<span class="number">184</span>,<span class="number">173</span>,<span class="number">229</span>,<span class="number">155</span>,<span class="number">189</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> =<span class="type">str</span>::<span class="title function_ invoke__">from_utf8</span>(&amp;c).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,s1);</span><br><span class="line">    <span class="comment">// &amp;str转数组</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">ss</span> = <span class="string">&quot;hello 中国&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">bb</span> = s.<span class="title function_ invoke__">as_bytes</span>();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,bb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-8-4-2-String转换-str"><a href="#3-8-4-2-String转换-str" class="headerlink" title="3.8.4.2 String转换&amp;str"></a>3.8.4.2 String转换&amp;str</h4><blockquote>
<p>从String类型转变为&amp;str是非常便捷的而且无损的（性能无损，不会造成重写malloc或者数据移动）<br>另外，由于Rust实现了自动解引用，那么&amp;String在必要的时候可以自动转换为&amp;str，因此在很多函数中，如果接受参数是字符串的引用，通常会采用&amp;str作为入参，以获取更好的数据兼容性<br>字符串是UTF-8编码的，因此需要保证索引的字节刚好落在字符的边界</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> =<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello,world!&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">say_hello</span>(&amp;s);</span><br><span class="line">    <span class="title function_ invoke__">say_hello</span>(&amp;s[..]);</span><br><span class="line">    <span class="title function_ invoke__">say_hello</span>(s.<span class="title function_ invoke__">as_str</span>());</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">fn</span> <span class="title function_">say_hello</span>(s: &amp;<span class="type">str</span>)&#123;</span><br><span class="line">     <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,s);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-8-4-3-字节数组Vec转换String"><a href="#3-8-4-3-字节数组Vec转换String" class="headerlink" title="3.8.4.3 字节数组Vec转换String"></a>3.8.4.3 字节数组Vec<u8>转换String</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">b</span> = <span class="built_in">vec!</span>(<span class="number">104</span>,<span class="number">101</span>,<span class="number">108</span>,<span class="number">108</span>,<span class="number">111</span>,<span class="number">32</span>,<span class="number">228</span>,<span class="number">184</span>,<span class="number">173</span>,<span class="number">229</span>,<span class="number">155</span>,<span class="number">189</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from_utf8</span>(b).<span class="title function_ invoke__">unwrap</span>();</span><br><span class="line">    <span class="title function_ invoke__">println</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-8-4-4-str转换String"><a href="#3-8-4-4-str转换String" class="headerlink" title="3.8.4.4 &amp;str转换String"></a>3.8.4.4 &amp;str转换String</h4><blockquote>
<p>从一个&amp;str获得一个String是低效的，因为创建String需要把数据保存在堆上，需要重新申请内存。</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello 世界&quot;</span>)；</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-8-5-操作字符串"><a href="#3-8-5-操作字符串" class="headerlink" title="3.8.5 操作字符串"></a>3.8.5 操作字符串</h3><h4 id="3-8-5-1-追加（Push）"><a href="#3-8-5-1-追加（Push）" class="headerlink" title="3.8.5.1 追加（Push）"></a>3.8.5.1 追加（Push）</h4><ul>
<li>使用push()方法追加字符char</li>
<li>使用push_str()方法追加字符串字面量</li>
<li>两个方法都是在原有字符串上追加，并不会返回新的字符串</li>
<li>字符串追加操作要修改原来的字符串，则该字符串必须是可变的，即字符串变量必须由mut关键词修饰</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    s.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot; rust&quot;</span>);</span><br><span class="line">    s.<span class="title function_ invoke__">push</span>(<span class="symbol">&#x27;char</span>&#x27;);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-8-5-2-插入（Insert）"><a href="#3-8-5-2-插入（Insert）" class="headerlink" title="3.8.5.2 插入（Insert）"></a>3.8.5.2 插入（Insert）</h4><ul>
<li>使用insert()方法插入单个字符char</li>
<li>使用insert_str()方法插入字符串字面量</li>
<li>这两个方法需要传入两个参数，第一个是字符&#x2F;字符串插入的位置索引，索引从0开始计数；第二个参数是要插入的字符&#x2F;字符串<ul>
<li>如果越界会发生错误</li>
<li>如果参数所给的位置不是合法的字符边界，也会发生错误</li>
</ul>
</li>
<li>由于字符插入的操作需要修改原字符串，则该字符串必须是可变的，即字符串变量必须由mut关键字修饰</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> =<span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;Hello rust!中文&quot;</span>);</span><br><span class="line">    s.<span class="title function_ invoke__">insert</span>(<span class="number">5</span>,<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,s);</span><br><span class="line">    s.<span class="title function_ invoke__">insert</span>(<span class="number">13</span>,<span class="string">&#x27;,&#x27;</span>); <span class="comment">//报错，不是合法字符边界，中文占三个字符</span></span><br><span class="line">    s.<span class="title function_ invoke__">insert_str</span>(<span class="number">6</span>,<span class="string">&quot;i like&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-8-5-3-替换（Replace）"><a href="#3-8-5-3-替换（Replace）" class="headerlink" title="3.8.5.3 替换（Replace）"></a>3.8.5.3 替换（Replace）</h4><h5 id="1-replace"><a href="#1-replace" class="headerlink" title="1.replace()"></a>1.replace()</h5><ul>
<li>replace()方法接收两个参数，第一个参数是要被替换的字符串，第二个参数是新的字符串</li>
<li>该方法会替换所有匹配到的字符串</li>
<li>该方法是返回一个新的字符串，而不是操作原来的字符串</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> =<span class="type">String</span>::<span class="title function_ invoke__">From</span>(<span class="string">&quot;I like rust&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">new_s</span> = s.<span class="title function_ invoke__">replace</span>(<span class="string">&quot;rust&quot;</span>,<span class="string">&quot;Rust&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,snew_s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-replacen"><a href="#2-replacen" class="headerlink" title="2.replacen()"></a>2.replacen()</h5><ul>
<li>replacen()接收三个参数，前两个参数和replace()是一样的，第三个参数表示替换个数</li>
<li>该方法是返回一个新的字符串，而不是操作原来的字符串</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> =<span class="type">String</span>::<span class="title function_ invoke__">From</span>(<span class="string">&quot;I like rust&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">new_s</span> = s.<span class="title function_ invoke__">replace</span>(<span class="string">&quot;rust&quot;</span>,<span class="string">&quot;Rust&quot;</span>,<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,snew_s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3-replace-range"><a href="#3-replace-range" class="headerlink" title="3.replace_range()"></a>3.replace_range()</h5><ul>
<li>replace_range()接收两个参数，第一个参数是要替换字符串的范围（Range），第二个参数是新的字符</li>
<li>该方法是直接操作原来的字符串，不会返回新的字符串。</li>
<li>该方法需要使用mut关键字修饰</li>
<li>如果range范围大于&#x2F;小于新字符串长度会怎样？</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> =<span class="type">String</span>::<span class="title function_ invoke__">From</span>(<span class="string">&quot;I like rust&quot;</span>);</span><br><span class="line">    s.<span class="title function_ invoke__">replace_range</span>(<span class="number">7</span>..<span class="number">8</span>,<span class="string">&quot;Rust&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-8-5-4-删除（remove）"><a href="#3-8-5-4-删除（remove）" class="headerlink" title="3.8.5.4 删除（remove）"></a>3.8.5.4 删除（remove）</h4><h5 id="1-pop"><a href="#1-pop" class="headerlink" title="1.pop()"></a>1.pop()</h5><ul>
<li>删除并返回字符串最后一个字符</li>
<li>其返回值是一个Option类型，如果字符串为空，则返回None</li>
<li>该方法是直接操作原来字符串</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> =<span class="type">String</span>::<span class="title function_ invoke__">From</span>(<span class="string">&quot;I like rust&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">p</span> = s.<span class="title function_ invoke__">pop</span>();</span><br><span class="line">    <span class="title function_ invoke__">println</span>(<span class="string">&quot;&#123;&#125;,&#123;&#125;&quot;</span>,p,s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-remove"><a href="#2-remove" class="headerlink" title="2.remove()"></a>2.remove()</h5><ul>
<li>该方法直接操作原来的字符串</li>
<li>其返回值是删除位置的字符串</li>
<li>只接收一个参数，表示该字符起始索引位置</li>
<li>方法是按照字节来处理字符的，如果给定的边界不合法，会发生错误</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">From</span>(<span class="string">&quot;测试remove方法&quot;</span>);</span><br><span class="line">    <span class="comment">// s.remove(0); //删除第一个中文</span></span><br><span class="line">    s.<span class="title function_ invoke__">remove</span>(<span class="number">3</span>); <span class="comment">//删除第二个中文</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-truncate"><a href="#3-truncate" class="headerlink" title="3.truncate()"></a>3.truncate()</h5><ul>
<li>删除字符串中从指定位置开始到结尾的全部字符</li>
<li>方法是按照字节处理字符串的，如果参数所给的位置不是合法边界，会发生错误</li>
<li>该方法是直接操作原来的字符串的</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">From</span>(<span class="string">&quot;测试truncate&quot;</span>);</span><br><span class="line">    s.<span class="title function_ invoke__">truncate</span>(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-clear"><a href="#3-clear" class="headerlink" title="3.clear()"></a>3.clear()</h5><ul>
<li>清空字符串</li>
<li>该方法是直接操作原来字符串<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">From</span>(<span class="string">&quot;测试 clear&quot;</span>);</span><br><span class="line">    s.<span class="title function_ invoke__">clear</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-8-5-5-连接（Concatenate）"><a href="#3-8-5-5-连接（Concatenate）" class="headerlink" title="3.8.5.5 连接（Concatenate）"></a>3.8.5.5 连接（Concatenate）</h4><h5 id="1-使用-add-连接字符串"><a href="#1-使用-add-连接字符串" class="headerlink" title="1. 使用+&#x2F;+&#x3D;&#x2F;add()连接字符串"></a>1. 使用+&#x2F;+&#x3D;&#x2F;add()连接字符串</h5><ul>
<li>add()方法第二个参数必须为字符串的切片引用类型</li>
<li>+是返回一个新的字符串，所以变量声明可以不需要mut关键字修饰</li>
<li>+会发生所有权移动<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> =<span class="type">String</span>::<span class="title function_ invoke__">From</span>(<span class="string">&quot;Hello &quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">string_rust</span>=<span class="type">String</span>::<span class="title function_ invoke__">From</span>(<span class="string">&quot;rust&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">result</span> = s + &amp;string_rust;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="2-使用format-连接字符串"><a href="#2-使用format-连接字符串" class="headerlink" title="2. 使用format!连接字符串"></a>2. 使用format!连接字符串</h5><ul>
<li>format!的用法与print!的用法相似</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello &quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s2</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;world&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="built_in">format!</span>(<span class="string">&quot;&#123;&#125;&#123;&#125;&quot;</span>,s1,s2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/Rust-study-notes/">Rust study notes</a>

      
      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-Rust基础3-数据类型（一）原生数据类型"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/Rust-study-notes/Rust%E5%9F%BA%E7%A1%803-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%88%E4%B8%80%EF%BC%89%E5%8E%9F%E7%94%9F%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">Rust基础3-数据类型（一）原生数据类型</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/Rust-study-notes/Rust%E5%9F%BA%E7%A1%803-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%88%E4%B8%80%EF%BC%89%E5%8E%9F%E7%94%9F%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/" class="article-date">
	  <time datetime="2024-09-22T01:55:17.000Z" itemprop="datePublished">九月 22, 2024</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/Rust-study-notes/">Rust study notes</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Rust-基础（3）-数据类型（一）原生数据类型"><a href="#Rust-基础（3）-数据类型（一）原生数据类型" class="headerlink" title="Rust 基础（3） - 数据类型（一）原生数据类型"></a>Rust 基础（3） - 数据类型（一）原生数据类型</h1><ul>
<li>rust类型概览</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
<th>值</th>
</tr>
</thead>
<tbody><tr>
<td>i8、i16、i32、i64、u8、u16、u32、u64</td>
<td>给定位宽的有符号整数和无符号整数</td>
<td>10、-10i8、b’*’</td>
</tr>
<tr>
<td>isize、usize</td>
<td>与机器字（32位或64位）一样大的有符号和无符号整数</td>
<td>137、-213121isize</td>
</tr>
<tr>
<td>f32、f64</td>
<td>单精度浮点数和双精度浮点数</td>
<td>1.001、3.14f32</td>
</tr>
<tr>
<td>bool</td>
<td>布尔值</td>
<td>true、false</td>
</tr>
<tr>
<td>char</td>
<td>unicode字符，32位</td>
<td>‘a’、’阿’、’\u’</td>
</tr>
<tr>
<td>(char,bool,)</td>
<td>元祖，允许混合类型</td>
<td>（’%’,0x7f,-1）</td>
</tr>
<tr>
<td>()</td>
<td>空元祖，单元</td>
<td>（）</td>
</tr>
<tr>
<td>struct S {x:f32,y:f32}</td>
<td>具名字段型结构体</td>
<td>S{x: 120.0,y: 209.0}</td>
</tr>
<tr>
<td>struct T (i32,char)</td>
<td>元祖型结构体</td>
<td>T(120,’X’)</td>
</tr>
<tr>
<td>struct E;</td>
<td>单元型结构体,类似class</td>
<td>E</td>
</tr>
<tr>
<td>enum Attend{OnTime, Late(u32)}</td>
<td>枚举、或代数数据类型</td>
<td>Attend::Late(5)、Attend::OnTime</td>
</tr>
<tr>
<td>Box<Attend></td>
<td>Box:指向堆中值的拥有型指针</td>
<td>Box::new(Late(15))</td>
</tr>
<tr>
<td>&amp;i32、&amp;mut i32</td>
<td>共享引用和可变引用：非拥有型指针，其生命周期不能超出引用目标</td>
<td>&amp;s.y、&amp;mut v</td>
</tr>
<tr>
<td>String</td>
<td>UTF-8字符串，动态分配大小</td>
<td>“abc”.to_string()</td>
</tr>
<tr>
<td>&amp;str</td>
<td>对str的引用：指向UTF-8文本的非拥有型指针</td>
<td>“abc”、&amp;s[0..12]</td>
</tr>
<tr>
<td>[f64;4]、[u8;256]</td>
<td>数组，固定长度，其元素类型都相同</td>
<td>[1.0,0.0]、[b’’;256]</td>
</tr>
<tr>
<td>Vec<f64></td>
<td>向量，可变长度，其元素类型都相同</td>
<td>vec![0.357,2.18]</td>
</tr>
<tr>
<td>&amp;[u8]、*mut [u8]</td>
<td>对切片（数组或向量某一部分）的引用，包含指针和长度</td>
<td>&amp;v[10..20]、&amp;mut a[..]</td>
</tr>
<tr>
<td>Option&lt;&amp;str&gt;</td>
<td>可选值：或者为None（无值），或者为Some（v）（有值，其值为v）</td>
<td>Some（”Do.”）、None</td>
</tr>
<tr>
<td>Result</td>
<td>可能失败的操作结果：或者为成功值Ok(v)，或者为错误值Err(e)</td>
<td>Ok(4000)、Err(Error::last_os_error())</td>
</tr>
<tr>
<td>&amp;dyn Any、&amp;mut dyn Read</td>
<td>特型对象，是对任何实现了一组给定方法的值的引用</td>
<td>value as &amp;dyn Any、&amp;mut file as &amp;mut dyn Read</td>
</tr>
<tr>
<td>fn(&amp;str) -&gt; bool</td>
<td>函数指针</td>
<td>str::is_empty</td>
</tr>
<tr>
<td>(闭包类型没有显示书写类型)</td>
<td>闭包</td>
<td></td>
</tr>
<tr>
<td>x..&#x3D;y</td>
<td>序列</td>
<td>1..&#x3D;4</td>
</tr>
</tbody></table>
<h2 id="3-1-整型（integers）"><a href="#3-1-整型（integers）" class="headerlink" title="3.1 整型（integers）"></a>3.1 整型（integers）</h2><ul>
<li>根据数据大小、有无符号可以分为如下类型：</li>
</ul>
<table>
<thead>
<tr>
<th>大小</th>
<th>有符号</th>
<th>无符号</th>
</tr>
</thead>
<tbody><tr>
<td>8位</td>
<td>i8</td>
<td>u8</td>
</tr>
<tr>
<td>16位</td>
<td>i16</td>
<td>u16</td>
</tr>
<tr>
<td>32位</td>
<td>i32</td>
<td>u32</td>
</tr>
<tr>
<td>64位</td>
<td>i64</td>
<td>u64</td>
</tr>
<tr>
<td>128位</td>
<td>i128</td>
<td>u128</td>
</tr>
<tr>
<td>cpu位数</td>
<td>isize</td>
<td>usize</td>
</tr>
</tbody></table>
<ul>
<li>整型字面量有以下书写方式：</li>
</ul>
<table>
<thead>
<tr>
<th>数字字面量</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>十进制</td>
<td>98_222</td>
</tr>
<tr>
<td>十六进制</td>
<td>0xff</td>
</tr>
<tr>
<td>八进制</td>
<td>0o77</td>
</tr>
<tr>
<td>二进制</td>
<td>0b1111_0000</td>
</tr>
<tr>
<td>字节</td>
<td>（仅限于u8）b’A’</td>
</tr>
</tbody></table>
<h2 id="3-2-浮点型（floating-point）"><a href="#3-2-浮点型（floating-point）" class="headerlink" title="3.2 浮点型（floating point）"></a>3.2 浮点型（floating point）</h2><ul>
<li><strong>浮点类型数字</strong> 是带有小数点的数字，在Rust中浮点类型的数字也有两种基本类型：f32和f64，分别为32位和64位大小。默认的浮点类型是f64，在现代的CPU中它的速度与f32几乎相同，但是精度更高</li>
<li><strong>NaN值</strong>对于数学上未定义的结果，如负数开平方根，Rust浮点类型会使用NaN(Not a Number)来处理这些情况。任何与NaN交互的操作都会返回NaN，并且NaN不能用于比较（如断言），会导致程序失败。</li>
</ul>
<h2 id="3-3-布尔型（boolean）"><a href="#3-3-布尔型（boolean）" class="headerlink" title="3.3 布尔型（boolean）"></a>3.3 布尔型（boolean）</h2><ul>
<li>Rust中的布尔类型有两个可能的值：true和false，布尔值占用内存的大小为1个字节</li>
</ul>
<h2 id="3-4-字符型（char）"><a href="#3-4-字符型（char）" class="headerlink" title="3.4 字符型（char）"></a>3.4 字符型（char）</h2><ul>
<li>在Rust语言中这些都是字符，所有的Unicode值都可以作为Rust字符，包括单个中文、日文、韩文、emoji表情符号等等，都是合法的字符类型。</li>
<li>Unicode都是4个字节编码，因此字符类型也占用4个字节。</li>
</ul>
<h2 id="3-5-序列"><a href="#3-5-序列" class="headerlink" title="3.5 序列"></a>3.5 序列</h2><ul>
<li>Rust提供了一个非常简洁的方式，用来生成连续的数值，如1..5，生成从1到4的连续数字，不包含5；1..&#x3D;5生成从1到5的连续数字，包含5，它常常用于循环中。</li>
</ul>
<blockquote>
<p>类型强制转换:<br>在Rust中，as关键字用于在原始类型(如i64、f64、u64、char等)之间进行类型转换。然而，需要注意的是，as关键字并不适用于复合类型，比如String或其他用户定义的类型，对于复合类型的转换，通常需要使用其他方法或函数</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">i</span>:<span class="type">i32</span>=<span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">f</span>:<span class="type">f32</span>= i <span class="keyword">as</span> <span class="type">f32</span>; <span class="comment">// int转换为float </span></span><br></pre></td></tr></table></figure>

<h2 id="3-6-数组（Array）"><a href="#3-6-数组（Array）" class="headerlink" title="3.6 数组（Array）"></a>3.6 数组（Array）</h2><h3 id="3-6-1-数组"><a href="#3-6-1-数组" class="headerlink" title="3.6.1 数组"></a>3.6.1 数组</h3><blockquote>
<p>类型 <strong>[T;N]</strong> 表示 <strong>N</strong> 个值的数组，每个值的类型为 <strong>T</strong> 。<br>数组的大小是在编译期就已确定的常量，并且是类型的一部分，不能追加新元素和缩小数组</p>
</blockquote>
<ul>
<li>数组的定义其实就是为分配一段<strong>连续的相同数据类型的</strong>内存块；</li>
<li>数组是静态的。这意味着一旦定义和初始化，永远不可改变它的长度；</li>
<li>数组的元素有着相同的数据类型，每个元素都独占数据类型大小的内存块，也就是说，数组的内存大小等于数组长度乘以数组的数据类型大小；</li>
<li>数组中的每个元素都按照顺序依次存储，这个顺序号既代表元素的存储位置，也是数组元素的唯一标识，也就是<strong>数组下标</strong>。这个下标从0开始；</li>
<li>填充数组中的每个元素过程称为<strong>数组初始化</strong>，也就是说数组初始化就是为数组中每个元素赋值；</li>
<li>可以更新和修改数组的值，但不能删除数组元素，如果要删除功能，可以将元素值赋值为0，或者其他表示删除的值；</li>
</ul>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">arr</span>()&#123;</span><br><span class="line">    <span class="comment">//声明一个数组</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span>:[<span class="type">i32</span>;<span class="number">4</span>] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr2</span> = [<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr1</span> =[<span class="number">10</span>;<span class="number">4</span>]; <span class="comment">// arr1元素4个10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>数组的传参：值传递和引用传递，值传递不会改变原数组的元素，引用传递会改变原数组的元素<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 值传递</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">arr</span> = [<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>];</span><br><span class="line">    <span class="title function_ invoke__">update</span>(arr);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;arr=&#123;&#125;&quot;</span>,arr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">update</span>(<span class="keyword">mut</span> arr:[<span class="type">i32</span>;<span class="number">3</span>])&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;before=&#123;&#125;&quot;</span>,arr);</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">3</span>&#123;</span><br><span class="line">        arr[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;after=&#123;&#125;&quot;</span>,arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引用传递</span></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>()&#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">arr</span> = [<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>]; <span class="comment">//引用传递会改变原数组的值，所以需要定义一个可变数组</span></span><br><span class="line">    <span class="title function_ invoke__">update</span>(&amp;<span class="keyword">mut</span> arr);  <span class="comment">// 这里需要传递原数组（arr）的可变引用</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;arr=&#123;&#125;&quot;</span>,arr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">update_mut</span>(arr: &amp;<span class="keyword">mut</span> [<span class="type">i32</span>;<span class="number">3</span>])&#123; <span class="comment">//函数入参类型是可变引用类型</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;before=&#123;&#125;&quot;</span>,arr);</span><br><span class="line">    <span class="keyword">for</span> <span class="variable">i</span> <span class="keyword">in</span> <span class="number">0</span>..<span class="number">3</span>&#123;</span><br><span class="line">        arr[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;after=&#123;&#125;&quot;</span>,arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<blockquote>
<p>Rust语言中值专递和引用传递 <strong>tips</strong><br>Rust的函数参数既可以按值传递也可以按引用传递，具体取决于参数类型。<br>基本类型参数（如整数、浮点数、布尔值等）会按值传递。<br>复合类型参数（如数组、元组、结构体等）也会按值传递，但在传递时会自动进行复制操作，即“深拷贝”。<br>引用类型参数（如指向堆上分配的对象的指针、切片等）会按引用传递，即传递的是指针或引用的地址，而非具体的值。如果需要修改参数的值，必须使用可变引用（&amp;mut）。</p>
</blockquote>
<p>函数increment的参数num为&amp;mut i32类型，表示传递的是指向i32类型对象的可变引用。在函数内部，通过解引用运算符（*）修改了num所指向的值。由于传递的是可变引用，因此能够修改原始变量x的值。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">y</span> = &amp;<span class="keyword">mut</span> x;</span><br><span class="line">    <span class="title function_ invoke__">increment</span>(y);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, x); <span class="comment">// 输出11</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">increment</span>(num: &amp;<span class="keyword">mut</span> <span class="type">i32</span>) &#123;</span><br><span class="line">    *num += <span class="number">1</span>; <span class="comment">// 使用解引用运算符修改num所指向的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-6-2-数组切片"><a href="#3-6-2-数组切片" class="headerlink" title="3.6.2 数组切片"></a>3.6.2 数组切片</h3><blockquote>
<p>类型 <strong>&amp;</strong> <strong>[T]</strong>  和 <strong>&amp;mut</strong> <strong>[T]</strong> 可称为T的共享切片和T的可变切片，它们是对一系列元素的引用，这些元素是某个其他值（数组或向量）的一部分。<br>可以将切片视为指向其第一个元素的指针，以及从该点开始允许访问的元素量的计数。<br>可变切片 &amp;mut [T]允许读取元素和修改元素，但不能共享；共享切片 &amp;[T] 允许在多个读者之间共享访问权限，但不允许修改元素。</p>
</blockquote>
<ul>
<li>切片（slice）表示从某个包含多个元素的容器中取得局部数据，这个过程称为切片操作。</li>
<li>不同语言对切片的支持有所不同，比如有些语言只允许取得连续的局部元素，而有些语言可以取得离散元素，甚至有些语言可以对hash结构进行切片操作。</li>
<li>rust只允许获取一段连续的局部数据，切片操作获取到的数据称为切片数据</li>
<li>rust常见的数据类型中，有三种类型支持切片操作：String类型、Array类型、Vec类型</li>
</ul>
<h4 id="3-6-2-1-数组切片声明"><a href="#3-6-2-1-数组切片声明" class="headerlink" title="3.6.2.1 数组切片声明"></a>3.6.2.1 数组切片声明</h4><ul>
<li>切片变量的类型是&amp;[i32]，通过存储第一个集合元素的引用和一个集合总长度，你可以对其他所有集合使用这类切片变量。<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 切片声明方法，切片的声明类型&amp;[i32]</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = &amp;a[<span class="number">1</span>..<span class="number">3</span>];</span><br><span class="line"><span class="keyword">let</span> <span class="variable">mut_slice</span> = &amp;<span class="keyword">mut</span> a[<span class="number">1</span>..<span class="number">3</span>]; </span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-6-2-1-切片常用函数"><a href="#3-6-2-1-切片常用函数" class="headerlink" title="3.6.2.1 切片常用函数"></a>3.6.2.1 切片常用函数</h4><ul>
<li><strong>len()</strong>:取slice元素个数</li>
<li><strong>is_empty()</strong>:判断slice是否为空</li>
<li><strong>contains()</strong>:判断是否包含某个元素</li>
<li><strong>repeat()</strong>:重复slice指定次数？</li>
<li><strong>reverse()</strong>:反转slice</li>
<li><strong>join()</strong>:将各个元素压平（flatten）并通过指定的分隔符连接起来</li>
<li><strong>swap()</strong>:交换两个索引处的元素，例s.swap(1,2)</li>
<li><strong>windows()</strong>:以指定大小的窗口滚动迭代</li>
<li><strong>starts_with()</strong>:判断slice是否以某个slice开头</li>
</ul>
<h2 id="3-7-元组（tuple）"><a href="#3-7-元组（tuple）" class="headerlink" title="3.7 元组（tuple）"></a>3.7 元组（tuple）</h2><h3 id="3-7-1-元组"><a href="#3-7-1-元组" class="headerlink" title="3.7.1 元组"></a>3.7.1 元组</h3><ul>
<li>元组类型是由其他类型的异构列表组合成的一类结构化类型。</li>
<li>元组类型的语法规则为一对圆括号封闭的逗号分割的类型列表。 为和圆括号类型区分开来，一元元组的元素类型后面需要有一个逗号。</li>
<li>元组类型的字段数量等同于其封闭的异构类型列表的长度。 字段的数量决定元组的元数(arity)。 有 n 个字段的元组叫做 n元元组(n-ary tuple)。 例如，有两个字段的元组就是二元元组。</li>
<li>元组的字段用它在列表中的位置数字来索引。 第一个字段索引为 0。 第二个字段索引为 1。 然后以此类推。 每个字段的类型都是元组类型列表中相同位置的类型。</li>
<li>出于方便和历史原因，不带元素(())的元组类型通常被称为单元(unit)或单元类型(unit type)。 它的值也被称为单元或单元值。</li>
</ul>
<h3 id="3-7-2-元组类型的示例："><a href="#3-7-2-元组类型的示例：" class="headerlink" title="3.7.2 元组类型的示例："></a>3.7.2 元组类型的示例：</h3><ul>
<li>() (单元)</li>
<li>(f64, f64)</li>
<li>(String, i32)</li>
<li>(i32, String) (跟前一个示例类型不一样)</li>
<li>(i32, f64, Vec<String>, Option<bool>)</li>
</ul>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/Rust-study-notes/">Rust study notes</a>

      
      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-Rust基础2-所有权和引用"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/Rust-study-notes/Rust%E5%9F%BA%E7%A1%802-%E6%89%80%E6%9C%89%E6%9D%83%E5%92%8C%E5%BC%95%E7%94%A8/">Rust基础2-所有权和引用</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/Rust-study-notes/Rust%E5%9F%BA%E7%A1%802-%E6%89%80%E6%9C%89%E6%9D%83%E5%92%8C%E5%BC%95%E7%94%A8/" class="article-date">
	  <time datetime="2024-09-16T01:52:25.000Z" itemprop="datePublished">九月 16, 2024</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/Rust-study-notes/">Rust study notes</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Rust-基础（2）-所有权和引用"><a href="#Rust-基础（2）-所有权和引用" class="headerlink" title="Rust 基础（2） - 所有权和引用"></a>Rust 基础（2） - 所有权和引用</h1><h2 id="1-1-所有权-ownership"><a href="#1-1-所有权-ownership" class="headerlink" title="1.1 所有权(ownership)"></a>1.1 所有权(ownership)</h2><blockquote>
<p><strong>零开销内存回收的一种高效实现方式</strong><br>Rust是一种系统编程语言，其设计目的是确保内存安全并防止数据竞争，而不依赖垃圾回收器。这种内存安全性主要通过所有权系统来实现。</p>
</blockquote>
<h3 id="1-1-1-静态语言和动态语言概念"><a href="#1-1-1-静态语言和动态语言概念" class="headerlink" title="1.1.1 静态语言和动态语言概念"></a>1.1.1 静态语言和动态语言概念</h3><ul>
<li>静态语言<ul>
<li>在编译时对变量类型进行检查和确定的语言</li>
<li>C、C++、rust</li>
</ul>
</li>
<li>动态语言<ul>
<li>在运行时进行类型检查和确定的语言</li>
<li>javascript、python</li>
</ul>
</li>
</ul>
<h3 id="1-1-2-静态和动态语言差异对比："><a href="#1-1-2-静态和动态语言差异对比：" class="headerlink" title="1.1.2 静态和动态语言差异对比："></a>1.1.2 静态和动态语言差异对比：</h3><table>
<thead>
<tr>
<th>特性</th>
<th>静态语言</th>
<th>动态语言</th>
</tr>
</thead>
<tbody><tr>
<td><strong>类型检查时间</strong></td>
<td>编译时</td>
<td>运行时</td>
</tr>
<tr>
<td><strong>类型安全</strong></td>
<td>更安全，减少运行时类型错误</td>
<td>较灵活，但类型错误可能在运行时出现</td>
</tr>
<tr>
<td><strong>性能</strong></td>
<td>通常更高效，编译器优化</td>
<td>通常较低，运行时类型检查</td>
</tr>
<tr>
<td><strong>灵活性</strong></td>
<td>较低，需明确声明类型</td>
<td>较高，允许在运行时改变类型</td>
</tr>
<tr>
<td><strong>代码简洁性</strong></td>
<td>需要显示类型声明，代码相对冗长</td>
<td>通常更简洁，适合快速开发</td>
</tr>
<tr>
<td><strong>开发工具支持</strong></td>
<td>更强大的静态分析和重构工具</td>
<td>开发工具支持有限，但在快速开发上占优势</td>
</tr>
</tbody></table>
<h3 id="1-1-3-内存回收方式对比："><a href="#1-1-3-内存回收方式对比：" class="headerlink" title="1.1.3 内存回收方式对比："></a>1.1.3 内存回收方式对比：</h3><h5 id="1）-C-C-等静态语言："><a href="#1）-C-C-等静态语言：" class="headerlink" title="1） C&#x2F;C++等静态语言："></a>1） C&#x2F;C++等静态语言：</h5><ul>
<li><strong>内存管理方式</strong>：手动管理（Manual Management）</li>
<li><strong>特点</strong>：<ul>
<li>程序员通过malloc和free（C语言）或new和delete（C++）手动分配和释放内存。</li>
<li>没有内置的垃圾回收机制</li>
</ul>
</li>
<li><strong>优点</strong>：<ul>
<li>高效且灵活，适用于对性能要求极高的系统级编程。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>容易出现内存泄漏、悬垂指针和缓冲区溢出等问题，需要非常小心的内存管理。</li>
</ul>
</li>
</ul>
<h5 id="2）-javascript等动态语言："><a href="#2）-javascript等动态语言：" class="headerlink" title="2） javascript等动态语言："></a>2） javascript等动态语言：</h5><ul>
<li><strong>内存管理方式</strong>：垃圾回收（Garbage Collection）</li>
<li><strong>特点</strong>：<ul>
<li>浏览器和Node.js环境中均使用垃圾回收器（如V8引擎的垃圾回收器）。</li>
<li>采用标记-清除（Mark and Sweep）、标记-压缩（Mark and Compact）分代回收等算法，java语言也是这种回收机制</li>
</ul>
</li>
<li><strong>优点</strong>：<ul>
<li>自动内存管理，适合快速开发和运行在多平台上的应用。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>垃圾回收机制可能在某些情况下导致性能问题，如UI线程停顿。</li>
</ul>
</li>
</ul>
<h5 id="3）-Rust语言："><a href="#3）-Rust语言：" class="headerlink" title="3） Rust语言："></a>3） Rust语言：</h5><ul>
<li><strong>内存管理方式</strong>：所有权系统（Ownership System）</li>
<li><strong>特点</strong>：<ul>
<li>Ruet使用所有权系统进行内存管理，编译器在编译时通过静态分析来确保内存安全。</li>
<li>每个值都有一个所有者，在任何时候只能有一个有效的所有者。</li>
<li>通过借用（引用）机制来共享数据，同时保证数据竞争和悬空指针的安全。</li>
</ul>
</li>
<li><strong>优点</strong>：<ul>
<li>在编译时保证内存安全，没有运行时开销。</li>
<li>避免数据竞争和悬空指针。</li>
</ul>
</li>
<li><strong>缺点</strong>：<ul>
<li>需要程序员理解和遵循所有权和借用规则，学习曲线较陡。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>小思考</strong>：什么时候分配栈内存，什么时候分配堆内存？<br>基本类型长度已知所以值会被分配到栈内存中，而对于 String 类型，为了支持一个可变，可增长的文本片段，需要在堆上分配一块在编译时未知大小的内存来存放内容，字符串的指针会存储在栈内存中。</p>
</blockquote>
<h3 id="1-1-4-所有权规则"><a href="#1-1-4-所有权规则" class="headerlink" title="1.1.4 所有权规则"></a>1.1.4 所有权规则</h3><blockquote>
<p>Rust是一种系统编程语言，其设计目的是确保内存安全并防止数据竞争，而不依赖垃圾回收器。这种内存安全性主要通过所有权系统来实现。</p>
</blockquote>
<ul>
<li><strong>所有权的基本规则</strong>：<ul>
<li>每一个值都有一个所有者；</li>
<li>在任一时刻，值只能有一个所有者；</li>
<li>当所有者离开作用域（scope），值会被丢弃（drop）</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>小思考</strong>：所有权机制为什么能够解决悬空指针的问题 ？<br>悬空指针是指针指向的已经被释放的一片内存，出现的原因是存在多个指针指向同一个内存地址，其中一个释放内存，但是其他指针还是指向这里。rust的内存只有一个所有者，根本上解决了这个问题。</p>
</blockquote>
<h3 id="1-1-5-如何分配所有权？"><a href="#1-1-5-如何分配所有权？" class="headerlink" title="1.1.5 如何分配所有权？"></a>1.1.5 如何分配所有权？</h3><h5 id="Rust特殊变量与数据交互方式（一）移动："><a href="#Rust特殊变量与数据交互方式（一）移动：" class="headerlink" title="Rust特殊变量与数据交互方式（一）移动："></a>Rust特殊变量与数据交互方式（一）移动：</h5><p>rust代码的意思是，第一行堆内存中生成的字符串“hello”绑定到s1上，此时s1拥有“hello”的所有权，第二行执行以后，s1指向的“hello”被移动到s2上，此时，s2拥有“hello”的所有权，s1不再有效</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = s1;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;s2&#125;, world!&quot;</span>);  </span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;s1&#125;, world!&quot;</span>);  <span class="comment">// 此时打印s1会报错</span></span><br></pre></td></tr></table></figure>
<h5 id="Rust特殊变量与数据交互方式（一）克隆："><a href="#Rust特殊变量与数据交互方式（一）克隆：" class="headerlink" title="Rust特殊变量与数据交互方式（一）克隆："></a>Rust特殊变量与数据交互方式（一）克隆：</h5><p>当我们真正需要深度复制 String 中堆上的数据，而不仅仅是栈上的数据，可以使用一个叫做 clone 的通用函数：执行clone函数以后，“hello”被复制了一份，绑定到s2上，此时s1和s2各拥有一个“hello”</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = s1.<span class="title function_ invoke__">clone</span>();</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;s1 = &#123;s1&#125;, s2 = &#123;s2&#125;&quot;</span>);</span><br></pre></td></tr></table></figure>


<h2 id="1-2-引用（References）"><a href="#1-2-引用（References）" class="headerlink" title="1.2 引用（References）"></a>1.2 引用（References）</h2><blockquote>
<p><strong>不可变引用（Immutable Reference）</strong>：通过不可变引用，可以读取数据，但不能修改数据。一个变量可以有多个不可变引用，但不能与可变引用共存。<br><strong>可变引用（Mutable Reference）</strong>：通过可变引用，可以读取和修改数据。一个变量在某一时刻只能有一个可变引用，且不能与不可变引用共存。</p>
</blockquote>
<h3 id="1-2-1-引用规则"><a href="#1-2-1-引用规则" class="headerlink" title="1.2.1 引用规则"></a>1.2.1 引用规则</h3><ul>
<li>同一时间内，一个变量只能有一个可变引用或多个不可变引用</li>
<li>引用必须总是有效。</li>
<li>引用规则和所有权规则区别。</li>
</ul>
<blockquote>
<p>参考书：<a target="_blank" rel="noopener" href="https://kaisery.github.io/trpl-zh-cn/ch04-02-references-and-borrowing.html">《Rust程序设计语言》-4.2节-引用与借用</a></p>
</blockquote>
<p>如下代码中，创建一个s1的引用传递给calculate_length方法，同时在函数定义中，我们获取 &amp;String 而不是 String。这些 &amp; 符号就是 引用，它们允许你使用值但不获取其所有权。<br><strong>&amp;s1 语法让我们创建一个 指向 值 s1 的引用，但是并不拥有它。因为并不拥有这个值，所以当引用停止使用时，它所指向的值也不会被丢弃。</strong><br><strong>同理，函数签名使用 &amp; 来表明参数 s 的类型是一个引用</strong><br><strong>当函数使用引用而不是实际值作为参数，无需返回值来交还所有权，因为就不曾拥有所有权。</strong></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s1</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">len</span> = <span class="title function_ invoke__">calculate_length</span>(&amp;s1);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The length of &#x27;&#123;s1&#125;&#x27; is &#123;len&#125;.&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">calculate_length</span>(s: &amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> <span class="type">usize</span> &#123; <span class="comment">// s 是 String 的引用</span></span><br><span class="line">    s.<span class="title function_ invoke__">len</span>()</span><br><span class="line">&#125; <span class="comment">// 这里，s 离开了作用域。但因为它并不拥有引用值的所有权，但是s1的值并不会消失</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2-2-移动（move）、借用（borrowing）、引用（referencing）"><a href="#1-2-2-移动（move）、借用（borrowing）、引用（referencing）" class="headerlink" title="1.2.2 移动（move）、借用（borrowing）、引用（referencing）"></a>1.2.2 移动（move）、借用（borrowing）、引用（referencing）</h3><h6 id="移动（move）、借用（borrowing）、引用（referencing）三者区别"><a href="#移动（move）、借用（borrowing）、引用（referencing）三者区别" class="headerlink" title="移动（move）、借用（borrowing）、引用（referencing）三者区别"></a>移动（move）、借用（borrowing）、引用（referencing）三者区别</h6><ul>
<li><strong>移动（move）</strong>：堆数据的所有权发生改变</li>
<li><strong>借用（borrowing）</strong>：创建一个引用的行为叫做借用，例如在函数入参中接收一个引用，就是借用</li>
<li><strong>引用（referencing）</strong>：像一个指针，因为它是一个地址，我们可以由此访问储存于该地址的属于其他变量的数据</li>
</ul>
<h3 id="1-2-3-可变引用"><a href="#1-2-3-可变引用" class="headerlink" title="1.2.3 可变引用"></a>1.2.3 可变引用</h3><blockquote>
<p>如果我们希望修改借用的值，那么就需要使用可变引用（Mutable reference）来实现。</p>
</blockquote>
<p>首先，我们必须将 s 改为 mut。然后在调用 change 函数的地方创建一个可变引用 &amp;mut s，并更新函数签名以接受一个可变引用 some_string: &amp;mut String。这就非常清楚地表明，change 函数将改变它所借用的值。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    <span class="title function_ invoke__">change</span>(&amp;<span class="keyword">mut</span> s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">change</span>(some_string: &amp;<span class="keyword">mut</span> <span class="type">String</span>) &#123;</span><br><span class="line">    some_string.<span class="title function_ invoke__">push_str</span>(<span class="string">&quot;, world&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可变引用有一个很大的限制：如果你有一个对该变量的可变引用，你就不能再创建对该变量的引用。这些尝试创建两个 s 的可变引用的代码会失败：因为我们不能在同一时间多次将 s 作为可变变量借用。第一个可变的借入在 r1 中，并且必须持续到在 println! 中使用它，但是在那个可变引用的创建和它的使用之间，我们又尝试在 r2 中创建另一个可变引用，该引用借用与 r1 相同的数据。</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ⚠️不能同时创建两个可变引用    </span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">r1</span> = &amp;<span class="keyword">mut</span> s;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">r2</span> = &amp;<span class="keyword">mut</span> s;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;, &#123;&#125;&quot;</span>, r1, r2);</span><br></pre></td></tr></table></figure>
<p>如果在创建r1以后在 println! 中使用它，就能继续创建r2</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">r1</span> = &amp;<span class="keyword">mut</span> s;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, r1);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">r2</span> = &amp;<span class="keyword">mut</span> s;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, r2);</span><br></pre></td></tr></table></figure>
<p>这一限制以一种非常小心谨慎的方式允许可变性，防止同一时间对同一数据存在多个可变引用。这个限制的好处是 Rust 可以在编译时就避免数据竞争。</p>
<blockquote>
<p>小tips：数据竞争（data race）类似于竞态条件，它可由这三个行为造成：</p>
</blockquote>
<ul>
<li>两个或更多指针同时访问同一数据。</li>
<li>至少有一个指针被用来写入数据。</li>
<li>没有同步数据访问的机制。</li>
</ul>
<h3 id="1-2-4-悬垂引用（Dangling-Reference）"><a href="#1-2-4-悬垂引用（Dangling-Reference）" class="headerlink" title="1.2.4 悬垂引用（Dangling Reference）"></a>1.2.4 悬垂引用（Dangling Reference）</h3><blockquote>
<p>在具有指针的语言中，很容易通过释放内存时保留指向它的指针而错误地生成一个 悬垂指针（dangling pointer），所谓悬垂指针是其指向的内存可能已经被分配给其它持有者。相比之下，在 Rust 中编译器确保引用永远也不会变成悬垂状态：当你拥有一些数据的引用，编译器确保数据不会在其引用之前离开作用域。</p>
</blockquote>
<p>悬垂引用错误代码示例：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">main</span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">reference_to_nothing</span> = <span class="title function_ invoke__">dangle</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">dangle</span>() <span class="punctuation">-&gt;</span> &amp;<span class="type">String</span> &#123; <span class="comment">// dangle 返回一个字符串的引用</span></span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>); <span class="comment">// s 是一个新字符串</span></span><br><span class="line">    &amp;s <span class="comment">// 返回字符串 s 的引用</span></span><br><span class="line">&#125; <span class="comment">// 这里 s 离开作用域并被丢弃。其内存被释放。</span></span><br><span class="line">  <span class="comment">// 危险！</span></span><br></pre></td></tr></table></figure>
<p>因为 s 是在 dangle 函数内创建的，当 dangle 的代码执行完毕后，s 将被释放。不过我们尝试返回它的引用。这意味着这个引用会指向一个无效的 String，这可不对！Rust 不会允许我们这么做。<br>正确的方式应该是直接返回 String，所有权被移动出去，所以没有值被释放</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">no_dangle</span>() <span class="punctuation">-&gt;</span> <span class="type">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="1-3-切片（slice）"><a href="#1-3-切片（slice）" class="headerlink" title="1.3 切片（slice）"></a>1.3 切片（slice）</h2><h3 id="1-3-1-字符串切片"><a href="#1-3-1-字符串切片" class="headerlink" title="1.3.1 字符串切片"></a>1.3.1 字符串切片</h3><p>字符串切片是对字符串部分内容的引用，使用&amp;s ：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">hello</span> = &amp;s[<span class="number">0</span>..<span class="number">5</span>]; <span class="comment">//引用hello</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">world</span> = &amp;s[<span class="number">6</span>..<span class="number">11</span>]; <span class="comment">//引用world</span></span><br></pre></td></tr></table></figure>

<p>字符串切片多种写法：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">a</span> = &amp;s[<span class="number">0</span>..<span class="number">5</span>] <span class="comment">//不包含第五个字符</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">b</span> = &amp;s[<span class="number">0</span>..=<span class="number">5</span>] <span class="comment">//包含第五个字符</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">c</span> = &amp;s[<span class="number">0</span>..len] <span class="comment">// 取整个字符串</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">d</span> = &amp;s[<span class="number">0</span>..] <span class="comment">//取整个字符串</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">e</span> = &amp;s[..]; <span class="comment">//取整个字符串</span></span><br></pre></td></tr></table></figure>

<p>“字符串 slice” 的类型声明写作 &amp;str</p>
<h3 id="1-4-生命周期（Lifetimes）"><a href="#1-4-生命周期（Lifetimes）" class="headerlink" title="1.4 生命周期（Lifetimes）"></a>1.4 生命周期（Lifetimes）</h3><p>生命周期是Rust用来保证引用有效性的机制。生命周期注解允许编译器推断引用的有效范围，确保在引用仍然有效时使用它们<br>生命周期是用撇号表示的：’a、’static</p>
<blockquote>
<p><strong>todo</strong> 这里没理解生命周期，后面理解后再补充！ </p>
</blockquote>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/Rust-study-notes/">Rust study notes</a>

      
      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  
    <article id="post-Rust基础1-变量"  class="article article-type-post" itemscope itemprop="blogPost" >
  <div id="articleInner" class="clearfix post-1016 post type-post status-publish format-standard has-post-thumbnail hentry category-template-2 category-uncategorized tag-codex tag-edge-case tag-featured-image tag-image tag-template">
    
    
      <header class="article-header">
        
  
    <h1 class="thumb" itemprop="name">
      <a class="article-title" href="/Rust-study-notes/Rust%E5%9F%BA%E7%A1%801-%E5%8F%98%E9%87%8F/">Rust基础1-变量</a>
    </h1>
  

      </header>
    
    <div class="article-meta">
      
	<a href="/Rust-study-notes/Rust%E5%9F%BA%E7%A1%801-%E5%8F%98%E9%87%8F/" class="article-date">
	  <time datetime="2024-09-15T01:52:25.000Z" itemprop="datePublished">九月 15, 2024</time>
	</a>

      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/Rust-study-notes/">Rust study notes</a>
 
      
    </div>
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Rust-基础（1）-变量和可变类型"><a href="#Rust-基础（1）-变量和可变类型" class="headerlink" title="Rust 基础（1） - 变量和可变类型"></a>Rust 基础（1） - 变量和可变类型</h1><h2 id="1-1-可变变量和不可变变量（Mutable-Immutable）"><a href="#1-1-可变变量和不可变变量（Mutable-Immutable）" class="headerlink" title="1.1 可变变量和不可变变量（Mutable&amp;Immutable）"></a>1.1 可变变量和不可变变量（Mutable&amp;Immutable）</h2><blockquote>
<p>Rust的变量默认是不可改变的（immutable）,如果我们想改变变量的值，就需要声明可变变量（mutable）</p>
</blockquote>
<h3 id="1-1-1-如何声明变量？"><a href="#1-1-1-如何声明变量？" class="headerlink" title="1.1.1 如何声明变量？"></a>1.1.1 如何声明变量？</h3><ul>
<li>声明不可变变量使用 <strong>let</strong> 关键字<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明不可变变量，使用let声明</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;&#125;&quot;</span>, x);</span><br></pre></td></tr></table></figure></li>
<li>声明可变变量使用 <strong>let mut</strong> 关键字<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明可变变量，使用let mut声明</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut </span><span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;&#125;&quot;</span>, x);</span><br><span class="line">x = <span class="number">6</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;The value of x is: &#123;&#125;&quot;</span>, x);</span><br></pre></td></tr></table></figure></li>
<li>指定变量类型，可以不显示指定类型<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单独声明变量类型(32位整型)，未赋值</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">x</span> : <span class="type">i32</span>;</span><br><span class="line"><span class="comment">// 声明变量类型并赋值</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">x</span> : <span class="type">i32</span> = <span class="number">100</span>;</span><br><span class="line"><span class="comment">// 未显示指定类型，但赋值</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">100</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="1-2-常量（Constants）"><a href="#1-2-常量（Constants）" class="headerlink" title="1.2 常量（Constants）"></a>1.2 常量（Constants）</h2><blockquote>
<p>Rust语言中使用const关键字来定义一个常量。定义常量时需要明确指定常量的数据类型，不指定类型会报错</p>
</blockquote>
<h3 id="1-2-1-常量的注意事项如下："><a href="#1-2-1-常量的注意事项如下：" class="headerlink" title="1.2.1 常量的注意事项如下："></a>1.2.1 常量的注意事项如下：</h3><ul>
<li>必须显示指定数据类型</li>
<li>常量名一般使用大写字母，否则编译器会警告（Warning）</li>
<li>必须使用常量表达式进行赋值，即编译器能够计算出的值</li>
<li>常量不支持重定义（遮蔽），这和变量不同</li>
</ul>
<h3 id="1-2-2-如何声明常量？"><a href="#1-2-2-如何声明常量？" class="headerlink" title="1.2.2 如何声明常量？"></a>1.2.2 如何声明常量？</h3><ul>
<li>声明常量使用 <strong>const</strong> 关键字<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明常量使用const关键字，并且需要显示定义数据类型（i32）</span></span><br><span class="line"><span class="keyword">const</span> C ：<span class="type">i32</span> = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">println!</span>(<span class="string">&quot;The value of C is: &#123;&#125;&quot;</span>, C);</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="1-2-3-不可变变量和常量的区别："><a href="#1-2-3-不可变变量和常量的区别：" class="headerlink" title="1.2.3 不可变变量和常量的区别："></a>1.2.3 不可变变量和常量的区别：</h3><table>
<thead>
<tr>
<th></th>
<th>不可变变量</th>
<th>常量</th>
</tr>
</thead>
<tbody><tr>
<td>声明关键字</td>
<td>let</td>
<td>const</td>
</tr>
<tr>
<td>值确定</td>
<td>运行时确定</td>
<td>编译时确定</td>
</tr>
<tr>
<td>值修改</td>
<td>使用遮蔽方式修改</td>
<td>不可修改</td>
</tr>
<tr>
<td>声明变量类型</td>
<td>可不声明类型</td>
<td>必须显示声明类型</td>
</tr>
<tr>
<td>命名</td>
<td>大小写均可</td>
<td>必须大写</td>
</tr>
</tbody></table>
<h2 id="1-3-静态变量（Static）"><a href="#1-3-静态变量（Static）" class="headerlink" title="1.3 静态变量（Static）"></a>1.3 静态变量（Static）</h2><blockquote>
<p>Rust的静态变量使用static关键字定义，声明的静态变量在编译时被分配内存，并在程序运行期一直存在<br>静态变量可以在整个程序中共享，并且可以在多个线程之间共享<br>静态变量的值在程序运行期间不会改变，因此它们通常用于存储程序的全局状态</p>
</blockquote>
<h3 id="1-3-1-如何声明静态变量？"><a href="#1-3-1-如何声明静态变量？" class="headerlink" title="1.3.1 如何声明静态变量？"></a>1.3.1 如何声明静态变量？</h3><ul>
<li>声明静态变量使用 <strong>static</strong> 关键字<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明静态变量：</span></span><br><span class="line"><span class="keyword">static</span> IDENTIFIER : <span class="type">i32</span> =<span class="number">10</span> ;</span><br></pre></td></tr></table></figure></li>
<li>声明可变静态变量使用 <strong>static mut</strong> 关键字，需要注意的是修改可变静态变量时需要使用 <strong>unsafe{}</strong> 代码块<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明可变静态变量，修改可变变量需要使用unsafe代码块</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">mut</span> IDENTIFIER : <span class="type">i32</span> =<span class="number">10</span> ;</span><br><span class="line"><span class="keyword">fn</span> <span class="title function_">static_mut</span>()&#123;</span><br><span class="line">    <span class="keyword">unsafe</span>&#123;</span><br><span class="line">        IDENTIFIER += <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;The value of IDENTIFIER is: &#123;&#125;&quot;</span>, IDENTIFIER);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>小tips</strong>：Safe Rust 和 <a target="_blank" rel="noopener" href="https://nomicon.purewhite.io/meet-safe-and-unsafe.html">Unsafe Rust</a> 之间的边界由unsafe关键字控制，unsafe是承接了它们之间交互的桥梁。这就是为什么我们可以说 Safe Rust是一种安全的语言：所有不安全的部分都被限制在“unsafe”边界之内。<br><strong>unsafe使用场景:</strong><br>对原始指针进行解引用<br>调用 “Unsafe” 的函数（包括 C 函数、编译器的内建指令和原始分配器）。<br>实现 “Unsafe” trait<br>访问或者修改可变的静态变量<br>访问 “union” 的字段</p>
</blockquote>
</li>
</ul>
<h3 id="1-3-2-静态变量与常量的相同点："><a href="#1-3-2-静态变量与常量的相同点：" class="headerlink" title="1.3.2 静态变量与常量的相同点："></a>1.3.2 静态变量与常量的相同点：</h3><ul>
<li>命名必须使用大写，否则编译器会报警告⚠️（Warning）</li>
<li>都必须定义变量类型</li>
<li>都必须使用常量表达式进行赋值，即编译器能够计算的值</li>
<li>两者都不支持重定义（遮蔽），这和变量不同</li>
</ul>
<h3 id="1-3-3-静态变量与常量的不同点："><a href="#1-3-3-静态变量与常量的不同点：" class="headerlink" title="1.3.3 静态变量与常量的不同点："></a>1.3.3 静态变量与常量的不同点：</h3><table>
<thead>
<tr>
<th></th>
<th>静态变量</th>
<th>常量</th>
</tr>
</thead>
<tbody><tr>
<td>声明关键字</td>
<td>static</td>
<td>const</td>
</tr>
<tr>
<td>编译时性质</td>
<td>唯一地址</td>
<td>编译时被内联</td>
</tr>
<tr>
<td>值可变性</td>
<td>可以使用mut定义可变</td>
<td>不可变</td>
</tr>
</tbody></table>
<h2 id="1-4-变量遮蔽（variable-shadowing）"><a href="#1-4-变量遮蔽（variable-shadowing）" class="headerlink" title="1.4 变量遮蔽（variable shadowing）"></a>1.4 变量遮蔽（variable shadowing）</h2><blockquote>
<p>变量绑定有一个作用域（scope），它被限定只在一个代码块（block）中生存（live），代码块是一个被{}包裹的语句集合。另外也允许变量遮蔽（variable shadowing）。</p>
</blockquote>
<h3 id="1-4-1-变量遮蔽与作用域特性"><a href="#1-4-1-变量遮蔽与作用域特性" class="headerlink" title="1.4.1 变量遮蔽与作用域特性"></a>1.4.1 变量遮蔽与作用域特性</h3><ul>
<li>变量可以在作用域中进行遮蔽，遮蔽后的值只在当前作用域生效</li>
<li>长生命周期的变量也可以在小作用域中遮蔽，遮蔽效果只能在小作用域中生效</li>
</ul>

      
    </div>
    <footer class="entry-meta entry-footer">
      
	<span class="ico-folder"></span>
    <a class="article-category-link" href="/categories/Rust-study-notes/">Rust study notes</a>

      
      
    </footer>
    <hr class="entry-footer-hr">
  </div>
  
</article>

<!-- Table of Contents -->

  


</section>
          <aside id="sidebar">
  
    <div style="margin: 20px 0;">
	<div id="search-form-wrap">

    <form class="search-form">
        <label style="width: 72%;">
            <span class="screen-reader-text">Search for:</span>
            <input type="search" class="search-field" style="height: 36px; width: 100%;" placeholder=" Search…" value="" name="s" title="Search for:">
        </label>
        <input type="submit" class="search-form-submit" value="Search">
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="Type something..."/>
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: 'Posts',
            PAGES: 'Pages',
            CATEGORIES: 'Categories',
            TAGS: 'Tags',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>


</div>
</div>
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Connect With Us</h3>
    <div class="widget widget_athemes_social_icons">

    	<ul class="clearfix widget-social-icons">   
    	
   			<li><a target="_blank" rel="noopener" href="https://github.com/iTimeTraveler" title="Github"><i class="fa fa-github" aria-hidden="true"></i></a></li> 

   		
   			<li><a href="" title="Weibo"><i class="fa fa-weibo" aria-hidden="true"></i></a></li> 

   		
   			<li><a href="" title="Twitter"><i class="fa fa-twitter" aria-hidden="true"></i></a></li> 

   		
   			<li><a href="" title="Facebook"><i class="fa fa-facebook" aria-hidden="true"></i></a></li> 

   		
   			<li><a href="" title="Google-plus"><i class="fa fa-google-plus" aria-hidden="true"></i></a></li> 

   		
   			<li><a href="" title="Instagram"><i class="fa fa-instagram" aria-hidden="true"></i></a></li> 

   		
   		</ul>


   		<!--
   		<ul class="clearfix widget-social-icons">   		
   		<li class="widget-si-twitter"><a target="_blank" rel="noopener" href="http://twitter.com" title="Twitter"><i class="ico-twitter"></i></a></li> 
		<li class="widget-si-facebook"><a target="_blank" rel="noopener" href="http://facebook.com" title="Facebook"><i class="ico-facebook"></i></a></li>
			<li class="widget-si-gplus"><a target="_blank" rel="noopener" href="http://plus.google.com" title="Google+"><i class="ico-gplus"></i></a></li>
			<li class="widget-si-pinterest"><a target="_blank" rel="noopener" href="http://pinterest.com" title="Pinterest"><i class="ico-pinterest"></i></a></li>
			<li class="widget-si-flickr"><a target="_blank" rel="noopener" href="http://flickr.com" title="Flickr"><i class="ico-flickr"></i></a></li>
			<li class="widget-si-instagram"><a target="_blank" rel="noopener" href="http://instagram.com" title="Instagram"><i class="ico-instagram"></i></a></li>
		</ul> -->

    </div>
  </div>


  
    
  <div class="widget_athemes_tabs">
    <ul id="widget-tab" class="clearfix widget-tab-nav">
      <li class="active"><a>Recent Posts</a></li>
    </ul>
    <div class="widget">
      <ul>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/Rust-study-notes/Rust%E5%9F%BA%E7%A1%803-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%88%E4%B8%89%EF%BC%89%E7%BB%93%E6%9E%84%E4%BD%93/">Rust基础3-数据类型（三）结构体</a></h6>
              <span>十月 2, 2024</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/Rust-study-notes/Rust%E5%9F%BA%E7%A1%803-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%88%E4%BA%8C%EF%BC%89%E5%AD%97%E7%AC%A6%E4%B8%B2/">Rust基础3-数据类型（二）字符串</a></h6>
              <span>九月 28, 2024</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/Rust-study-notes/Rust%E5%9F%BA%E7%A1%803-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%88%E4%B8%80%EF%BC%89%E5%8E%9F%E7%94%9F%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">Rust基础3-数据类型（一）原生数据类型</a></h6>
              <span>九月 22, 2024</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/Rust-study-notes/Rust%E5%9F%BA%E7%A1%802-%E6%89%80%E6%9C%89%E6%9D%83%E5%92%8C%E5%BC%95%E7%94%A8/">Rust基础2-所有权和引用</a></h6>
              <span>九月 16, 2024</span>
            </div>

          </li>
        
          <li class="clearfix">

            
              <div class="widget-entry-summary" style="margin: 0;">
            

              <h6 style="margin: 0;"><a href="/Rust-study-notes/Rust%E5%9F%BA%E7%A1%801-%E5%8F%98%E9%87%8F/">Rust基础1-变量</a></h6>
              <span>九月 15, 2024</span>
            </div>

          </li>
        
      </ul>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Rust-study-notes/">Rust study notes</a><span class="category-list-count">5</span></li></ul>
    </div>
  </div>


  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>

    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/10/">十月 2024</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/09/">九月 2024</a><span class="archive-list-count">4</span></li></ul>
    </div>
  </div>


  
</aside>
        
      </div>

    </div>
    <!-- <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/categories" class="mobile-nav-link">Categories</a>
  
    <a href="/tags" class="mobile-nav-link">Tags</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav> -->
    <footer id="footer" class="site-footer">
  

  <div class="clearfix container">
      <div class="site-info">
	      &copy; 2024 Shizi&#39;s BLOG All Rights Reserved.
        
            <span id="busuanzi_container_site_uv">
              本站访客数<span id="busuanzi_value_site_uv"></span>人次  
              本站总访问量<span id="busuanzi_value_site_pv"></span>次
            </span>
          
      </div>
      <div class="site-credit">
        Theme by <a href="https://github.com/iTimeTraveler/hexo-theme-hipaper" target="_blank">hipaper</a>
      </div>
  </div>
</footer>


<!-- min height -->

<script>
    var wrapdiv = document.getElementById("wrap");
    var contentdiv = document.getElementById("content");

    wrapdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";
    contentdiv.style.minHeight = document.body.offsetHeight - document.getElementById("allheader").offsetHeight - document.getElementById("footer").offsetHeight + "px";


    <!-- headerblur min height -->
    
    
</script>
    
<div style="display: none;">
  <script src="https://s11.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
</div>

<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$','$'], ["\\(","\\)"] ],
      processEscapes: true
    }
  });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>


<script src="/js/bootstrap.js"></script>


<script src="/js/main.js"></script>








  <div style="display: none;">
    <script src="https://s95.cnzz.com/z_stat.php?id=1260716016&web_id=1260716016" language="JavaScript"></script>
  </div>



	<!-- <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"> -->
	<script async src="//cdn.jsdelivr.net/gh/sukkaw/busuanzi@2.3/bsz.pure.mini.js">
	</script>






  </div>

  <a id="rocket" href="#top" class=""></a>
  <script type="text/javascript" src="/js/totop.js" async=""></script>
</body>
</html>
